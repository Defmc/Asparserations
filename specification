namespace asparserations

  //Namespace for grammar API
  namespace grammar
    class Grammar
      DATA
      class TokenImp : Token
      class NonterminalImp : Nonterminal
      std::map<std::string,TokenImp> _tokens
      std::map<std::string,NonterminalImp> _nonterminals

      METHODS
      Nonterminal& add_nonterminal(const std::string&)
      Token& add_token(const std::string&)
      [const] Token& token_at(const std::string&) [const]
      [const] Nonterminal& nonterminal_at(const std::string&) [const]

    class Symbol
      std::set<Token*>& first_set() = 0      
 
    class Token : public Symbol

    class Nonterminal : public Symbol
      DATA
      std::set<Token> first_set
      std::vector<Production> productions

      METHODS
      getter for first set
      getter for productions

    class Production
      std::vector<const Symbol*> symbols


  //Namespace for generating the state machine
  namespace table

    class Item
      DATA
      const Production& production
      int marker
      const Symbol& lookahead

      METHODS

    class Item_Set
      DATA
      std::set<Item> items

      METHODS
      bool merge(const tem_Set&)

    class State
      std::map<Symbol*, State*>

    class Table
      const std::set<State>& states() const = 0

    class LR_Table : public Table
      const std::set<State>& states() const

    class LALR_Table : public Table
      const std::set<State>& states() const

    class LALR_Item_Set
      // Items in OTHER item sets to give lookaheads to
      std::map<Item*,std::set<Item*>> spontaneous_paths
      // Items in same or other item sets to pass on given lookaheads to
      std::map<Item*,std::set<Item*>> propagate_paths
      // REal items
      std::set<Item> concrete_items

  namespace codegen
    class Code_Generator
      const std::string& code() const=0;

/**
 Outputted parser
*/

//path/include/$class_name.hpp
#include <array>
#include <vector>

$begin_namespace
class $class_name
{
public:
  $class_name($lexer&);
private:
  struct State
  {
    std::vector<std::pair<$lexer,unsigned int>> shifts;
    std::vector<std::pair<$lexer,std::vector<const Production*>>> reduces;
    std::vector<std::pair<Symbol,unsigned int>> gotos;
  };
  struct Continuation
  {
    enum class Action {shift, reduce, go_to};
    union {
      std::vector<std::pair<$lexer,unsigned int>>::iterator shift_index;
      std::vector<std::pair<$lexer,std::vector<const Production*>>>::iterator
        reduce_index;
      Symbol symbol;
    };

    $lexer lexer;
    unsigned int state;
    Node* node;
  };

  std::array<$state_count> _states;
  $lexer& _lexer;
  std::vector<Continuation> _continuation_stack;
  void _enter_state(Continuation&);
  void _reduce();
};
$end_namespace
//end

//path/src/$class_name.cpp
void $namespaces::$class_name::_enter_state(Continuation& c)
{
  State& s = this->_states.at(c.state);
  $lexer l = c.lexer;
  if(c.action == Continuation::Action::shift) {
    for(auto i = c.shift_index; i != s.shifts.end(); ++i) {
      //Call the token recognization function
      auto result = lexer.*(i->first);
      if(result.second) {
        c.shift_index = i;
	delete c.node;
        c.node = result.first;
        this->_continuation_stack.emplace_back(shift, i->second);
        return;
      }
    }
    c.action = Continuation::Action::reduce;
    c.reduce_index = s.reduces.begin();
  }
  if (c.action == Continuation::Action::reduce) {
    for(auto i = c.reduce_index; i != s.reduces.end(); ++i) {
      auto result = lexer.*(i->first);
      if(result.second) {
        c.reduce_index = i;
	this->_reduce();
	return;
      }
    }
    c.action = Continuation::Action::go_to;
  }
  if(c.action == Continuation::Action::go_to) {
    auto result = s.gotos.find(c.symbol);
    if(result.second) {
      this->_continuation_stack.emplace_back(Continuation::Action::Shift,
                                             result.first->shift);
      return;
    }
  }
  this->_continuation_stack.pop_back();
}

void $namespaces::$class_name::_reduce()
{

}

$namespace::$class_name::$class_name()
{
  _continuation_stack.emplace_back(Continuation::Action::shift, 0);
  while(!this->_continuation_stack.empty()) {
    this->_enter_state(this->_continuation_stack.back());
  }
}

/**
Lexer:
struct that aggregates tokens
*/
/**
Token:
Must have recognizer function and TokenKind
*/
/**
Lexer_State:
Output: New Lexer_State, Token node, bool for if it succeeded
*/

struct Lexer
{
  Lexer expect(Token) const;
};





//JSON Output
{
  "grammar" : {
    "tokens" : [
      "e"
    ],
    "nonterminals" : [
      "S" : {
        "root" : [
	  {
	    "id" : "e",
	    "isToken" : true
	  }
	]
      }
    ]
  },
  "table" : [
    {
      "actions:" {
        "e" : {
	  "shift" : null,
	  "reduces" : [
	    {
	      "nonterminal" : "S"
	      "production" : "root"
	    }
	  ]
	}
      }
      "gotos" : {
        "S" : 1
      }
    }
  ]
}
